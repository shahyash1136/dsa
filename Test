import React from "react";
import { render, screen, act } from "@testing-library/react";
import '@testing-library/jest-dom/extend-expect';
import DashBoard from "./DashBoard";

// Mock external modules
jest.mock("crypto-js", () => ({
  enc: {
    Utf8: {
      parse: jest.fn(),
      stringify: jest.fn(),
    },
  },
  AES: {
    decrypt: jest.fn().mockReturnValue({
      toString: jest.fn().mockReturnValue("decryptedValue"),
    }),
  },
}));

jest.mock("ag-grid-enterprise", () => ({}));

jest.mock("react-redux", () => ({
  Provider: ({ children }) => <div>{children}</div>,
}));

jest.mock("./MultiSearchCp", () => () => <div data-testid="multi-search-cp">MultiSearchCp Component</div>);

jest.mock("./redux/root-reducer", () => ({}));

jest.mock("./LicenseKey", () => ({
  text: "someText",
  setKey: jest.fn(),
}));

describe("DashBoard Component", () => {
  const mockStore = {
    injectReducer: jest.fn(),
  };

  const defaultProps = {
    store: mockStore,
    LimitUIResponse: "someResponse",
    LimitsReferenceData: "someReferenceData",
  };

  afterEach(() => {
    jest.clearAllMocks();
  });

  test("should render loading state initially", () => {
    render(<DashBoard {...defaultProps} />);
    
    // Ensure loading state is displayed initially
    expect(screen.getByText(/nbsp;/)).toBeInTheDocument();
  });

  test("should call injectReducer and setKey on mount", () => {
    render(<DashBoard {...defaultProps} />);
    
    // Check if injectReducer has been called
    expect(mockStore.injectReducer).toHaveBeenCalledWith("multiSearch", expect.any(Object));
    
    // Check if setKey has been called with the correct arguments
    expect(require("./LicenseKey").setKey).toHaveBeenCalledWith(
      "someText",
      expect.any(Object),  // LicenseManager mock
      expect.any(Object)   // CryptoJS mock
    );
  });

  test("should render MultiSearchCp component when store injection is completed", async () => {
    // Act is needed to ensure the component renders fully after state updates
    await act(async () => {
      render(<DashBoard {...defaultProps} />);
    });
    
    // Simulate that store injection has completed
    expect(await screen.findByTestId("multi-search-cp")).toBeInTheDocument();
  });

  test("should display loading text when store injection is incomplete", () => {
    render(<DashBoard {...defaultProps} />);
    
    // Assert that loading text is rendered initially
    expect(screen.getByText(/\u00a0/)).toBeInTheDocument(); // '&nbsp;' equivalent in JavaScript
  });

  test("should unmount and reset isStoreInjectCompleted to false", () => {
    const { unmount } = render(<DashBoard {...defaultProps} />);
    
    unmount();

    // Check if the cleanup effect (setIsStoreInjectCompleted(false)) is called on unmount
    expect(screen.queryByTestId("multi-search-cp")).not.toBeInTheDocument();
  });
});
