import React from 'react';
import { render, screen } from '@testing-library/react';
import DashBoard from './DashBoard';  // Adjust this path based on your structure

// Mock external modules used inside DashBoard
jest.mock('ag-grid-enterprise', () => ({}));
jest.mock('react-redux', () => ({
  Provider: ({ children }) => <div>{children}</div>,
}));

// Properly mock CryptoJS, especially decrypt and utf8 encoding/decoding
jest.mock('crypto-js', () => ({
  enc: {
    Utf8: {
      parse: jest.fn().mockReturnValue('parsedUtf8'),
      stringify: jest.fn().mockReturnValue('stringifiedUtf8'),
    },
  },
  AES: {
    encrypt: jest.fn().mockReturnValue('encryptedValue'),
    decrypt: jest.fn().mockReturnValue({
      toString: jest.fn().mockReturnValue('decryptedValue'),
    }),
  },
}));

jest.mock('./MultiSearchCp', () => ({ ...props }) => <div data-testid="MultiSearchCp" {...props} />);
jest.mock('./redux/root-reducer', () => ({}));

describe('DashBoard Component', () => {
  const mockStore = {
    asyncReducers: {
      multiSearch: true,
    },
    injectReducer: jest.fn(),  // Mocking injectReducer
  };

  const mockProps = {
    store: mockStore,
    tabName: 'testTab',
    LimitUIResponse: 'someResponse',
    LimitsReferenceData: 'someData',
    showLimitNav: true,
    anchorEl: null,
    uci: 'someUCI',
  };

  test('should render without crashing', () => {
    render(<DashBoard {...mockProps} />);
    expect(screen.getByText('testTab')).toBeInTheDocument(); // Assuming tabName is displayed somewhere
  });

  test('should call injectReducer on store', () => {
    render(<DashBoard {...mockProps} />);
    expect(mockStore.injectReducer).toHaveBeenCalledWith('multiSearch', expect.any(Function));
  });

  test('should conditionally render MultiSearchCp when data exists', () => {
    render(<DashBoard {...mockProps} />);
    const multiSearchCp = screen.getByTestId('MultiSearchCp');
    expect(multiSearchCp).toBeInTheDocument();
    expect(multiSearchCp).toHaveAttribute('hostData', 'someUCI'); // Assuming hostData is passed to MultiSearchCp
  });

  test('should not render MultiSearchCp when LimitUIResponse is empty', () => {
    const props = { ...mockProps, LimitUIResponse: '' };
    render(<DashBoard {...props} />);
    expect(screen.queryByTestId('MultiSearchCp')).not.toBeInTheDocument();
  });

  test('should display loading text when LimitsReferenceData is empty', () => {
    const props = { ...mockProps, LimitsReferenceData: '' };
    render(<DashBoard {...props} />);
    expect(screen.getByText('loadingImageNew')).toBeInTheDocument();
  });
});
