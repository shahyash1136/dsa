import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { useSelector } from 'react-redux';
import CPStatus from './CPStatus';
import { useDropDownSelection } from '../../../hooks/useDropDownSelection';
import '@testing-library/jest-dom/extend-expect';

// Mock useSelector from redux
jest.mock('react-redux', () => ({
    useSelector: jest.fn(),
}));

// Mock useDropDownSelection hook
jest.mock('../../../hooks/useDropDownSelection', () => ({
    useDropDownSelection: jest.fn(),
}));

describe('CPStatus Component', () => {
    const mockCounterpartyStatus = {
        value: [
            { value: 'Option 1' },
            { value: 'Option 2' },
        ],
    };

    const mockOnInputChange = jest.fn();
    const mockInputValueCPStatus = 'mockValue';

    const mockDropdownKey = 'counterpartyStatus'; // Simulate dropdown key from config
    const mockMultiple = true; // Simulate the multiple prop

    beforeEach(() => {
        // Mock useSelector to return counterpartyStatus
        useSelector.mockImplementation((callback) =>
            callback({
                multiSearch: {
                    dropDowns: {
                        counterpartyStatus: mockCounterpartyStatus,
                    },
                },
            })
        );

        // Mock useDropDownSelection to return onInputChange function and inputValue
        useDropDownSelection.mockImplementation((dropdownKey, multiple) => {
            // Assert correct parameters are passed to useDropDownSelection
            expect(dropdownKey).toEqual(mockDropdownKey);
            expect(multiple).toEqual(mockMultiple);

            return {
                onInputChange: mockOnInputChange,
                inputValueCPStatus: mockInputValueCPStatus,
            };
        });
    });

    afterEach(() => {
        jest.clearAllMocks();
    });

    it('renders CPStatus component with multiple options', () => {
        render(<CPStatus multiple={mockMultiple} />);

        // Assert the component renders correctly
        expect(screen.getByTestId('CPStatus-testid')).toBeInTheDocument();
        expect(screen.getByText('CPStatus / Category')).toBeInTheDocument();

        // Assert the options are rendered correctly
        mockCounterpartyStatus.value.forEach(option => {
            expect(screen.getByText(option.value)).toBeInTheDocument();
        });
    });

    it('calls onInputChange when option is selected', () => {
        render(<CPStatus multiple={mockMultiple} />);

        const inputElement = screen.getByTestId('CPStatus-testid');

        // Simulate selecting an option
        fireEvent.change(inputElement, { target: { value: 'Option 1' } });

        // Assert onInputChange has been called
        expect(mockOnInputChange).toHaveBeenCalledTimes(1);
    });

    it('handles single selection mode correctly', () => {
        render(<CPStatus multiple={false} />);

        // Assert that it still renders in single select mode
        expect(screen.getByTestId('CPStatus-testid')).toBeInTheDocument();
    });

    it('handles empty counterpartyStatus correctly', () => {
        // Mock useSelector to return empty counterpartyStatus
        useSelector.mockImplementation((callback) =>
            callback({
                multiSearch: {
                    dropDowns: {
                        counterpartyStatus: { value: [] },
                    },
                },
            })
        );

        render(<CPStatus multiple={mockMultiple} />);

        // Ensure no options are rendered
        expect(screen.queryByText('Option 1')).not.toBeInTheDocument();
    });

    it('displays the correct input value', () => {
        render(<CPStatus multiple={mockMultiple} />);

        // Assert that inputValueCPStatus is used correctly
        expect(screen.getByDisplayValue(mockInputValueCPStatus)).toBeInTheDocument();
    });
});
