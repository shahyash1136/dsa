import { renderHook, act } from "@testing-library/react-hooks";
import useSearchSuggestion from "./useSearchSuggestion";
import useDebounce from "./useDebounce";
import { useDispatch } from "react-redux";

// Mock useDebounce
jest.mock("./useDebounce");
jest.mock("react-redux", () => ({
  useDispatch: jest.fn(),
}));

describe("useSearchSuggestion", () => {
  let callbackFn;
  let dispatch;

  beforeEach(() => {
    callbackFn = jest.fn();
    useDebounce.mockImplementation((value) => value); // Directly return searchQuery for simplicity
    dispatch = jest.fn();
    useDispatch.mockReturnValue(dispatch);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test("should initialize with default values", () => {
    const { result } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", [])
    );
    const {
      suggestionList,
      loading,
      selectedValues,
      searchTerm,
    } = result.current;

    expect(suggestionList).toEqual([]);
    expect(loading).toBe(false);
    expect(selectedValues).toEqual([]);
    expect(searchTerm).toBe("");
  });

  test("should set searchQuery, trigger debounce, and fetch suggestions", async () => {
    const mockResponse = { suggestions: [{ id: 1, label: "Item 1" }] };
    callbackFn.mockResolvedValueOnce(mockResponse);

    const { result, waitForNextUpdate } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", [])
    );

    // Simulate typing in search input
    act(() => {
      result.current.handleInputChange({ target: { value: "test" } });
    });

    expect(result.current.searchTerm).toBe("test");
    expect(result.current.loading).toBe(true);

    // Wait for the async API call
    await waitForNextUpdate();

    expect(callbackFn).toHaveBeenCalledWith({ query: "test" });
    expect(result.current.suggestionList).toEqual(mockResponse.suggestions);
    expect(result.current.loading).toBe(false);
  });

  test("should clear suggestions when input is empty", async () => {
    const { result } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", [])
    );

    // Simulate clearing input
    act(() => {
      result.current.handleInputChange({ target: { value: "" } });
    });

    expect(result.current.suggestionList).toEqual([]);
    expect(result.current.loading).toBe(false);
  });

  test("should handle selection change and dispatch action", () => {
    const mockAction = jest.fn();
    const { result } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", mockAction, [])
    );

    const newSelection = [{ id: 1, label: "Selected Item" }];

    act(() => {
      result.current.handleSelectionChange(null, newSelection);
    });

    expect(result.current.selectedValues).toEqual(newSelection);
    expect(dispatch).toHaveBeenCalledWith(mockAction(newSelection));
  });

  test("should handle single select and reset selected values", async () => {
    const mockAction = jest.fn();
    const { result, waitForNextUpdate } = renderHook(() =>
      useSearchSuggestion(callbackFn, false, "suggestions", mockAction, [])
    );

    // Simulate input change
    act(() => {
      result.current.handleInputChange({ target: { value: "item" } });
    });

    expect(result.current.loading).toBe(true);

    // Simulate selection
    act(() => {
      result.current.handleSelectionChange(null, "Item 1");
    });

    expect(result.current.selectedValues).toEqual("Item 1");

    // Now clear input
    act(() => {
      result.current.handleInputChange({ target: { value: "" } });
    });

    // Wait for state updates and effects to be processed
    await waitForNextUpdate();

    expect(result.current.selectedValues).toBeNull();
  });

  test("should not fetch suggestions if debounceValue is empty", async () => {
    useDebounce.mockReturnValueOnce(""); // Simulate empty debounce value

    const { result } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", [])
    );

    // Simulate input change
    act(() => {
      result.current.handleInputChange({ target: { value: "" } });
    });

    expect(callbackFn).not.toHaveBeenCalled(); // No fetch when input is empty
    expect(result.current.suggestionList).toEqual([]);
  });

  test("should handle errors during suggestion fetching", async () => {
    const mockError = new Error("API Error");
    callbackFn.mockRejectedValueOnce(mockError);

    const { result, waitForNextUpdate } = renderHook(() =>
      useSearchSuggestion(callbackFn, true, "suggestions", [])
    );

    act(() => {
      result.current.handleInputChange({ target: { value: "test" } });
    });

    await waitForNextUpdate();

    expect(callbackFn).toHaveBeenCalled();
    expect(result.current.suggestionList).toEqual([]);
    expect(result.current.loading).toBe(false);
  });
});
